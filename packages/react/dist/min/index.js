import{useRef as t,useState as e,useEffect as n}from"react";var r={dragStart:!0},o=(t,e={})=>{let n,o,{bounds:f,axis:g="both",gpuAcceleration:p=!0,legacyTranslate:h=!0,transform:m,applyUserSelectHack:y=!0,disabled:b=!1,ignoreMultitouch:w=!1,recomputeBounds:v=r,grid:D,position:E,cancel:S,handle:x,touchAction:A="none",defaultClass:C="neodrag",defaultClassDragging:N="neodrag-dragging",defaultClassDragged:M="neodrag-dragged",defaultPosition:B={x:0,y:0},onDragStart:$,onDrag:H,onDragEnd:L}=e,R=!1,T=0,j=0,P=0,X=0,Y=0,k=0,{x:q,y:U}=E?{x:E?.x??0,y:E?.y??0}:B;V(q,U);let W,O,z,F,G,I="",J=!!E;v={...r,...v};const K=document.body.style,Q=t.classList;function V(e=T,n=j){if(!m){if(h){let r=`${+e}px, ${+n}px`;return l(t,"transform",p?`translate3d(${r}, 0)`:`translate(${r})`)}return l(t,"translate",`${+e}px ${+n}px ${p?"1px":""}`)}const r=m({offsetX:e,offsetY:n,rootNode:t});a(r)&&l(t,"transform",r)}const Z=(e,n)=>{const r={offsetX:T,offsetY:j,rootNode:t,currentNode:G};t.dispatchEvent(new CustomEvent(e,{detail:r})),n?.(r)};const _=addEventListener;let tt;if(_("pointerdown",nt,!1),_("pointerup",rt,!1),_("pointermove",ot,!1),"function"==typeof A)A(t,(e=>l(t,"touch-action",e)));else if("string"==typeof A)l(t,"touch-action",A);else{const e=Object.keys(A).map((t=>Number(t))).sort(((t,e)=>e-t));tt=n=>{const r=e.find((t=>n>=t));if("object"!=typeof A||"number"!=typeof r||"object"==typeof A&&!(r in A))return;const o=A[r];"string"==typeof o&&l(t,"touch-action",o)}}const et=()=>{let e=t.offsetWidth/O.width;return isNaN(e)&&(e=1),e};function nt(e){if(b)return;if(2===e.button)return;if(w&&!e.isPrimary)return;if(v.dragStart&&(W=d(f,t)),a(x)&&a(S)&&x===S)throw new Error("`handle` selector can't be same as `cancel` selector");if(Q.add(C),z=function(t,e){if(!t)return[e];if(u(t))return[t];if(Array.isArray(t))return t;const n=e.querySelectorAll(t);if(null===n)throw new Error("Selector passed for `handle` option should be child of the element on which the action is applied");return Array.from(n.values())}(x,t),F=function(t,e){if(!t)return[];if(u(t))return[t];if(Array.isArray(t))return t;const n=e.querySelectorAll(t);if(null===n)throw new Error("Selector passed for `cancel` option should be child of the element on which the action is applied");return Array.from(n.values())}(S,t),n=/(both|x)/.test(g),o=/(both|y)/.test(g),c(F,z))throw new Error("Element being dragged can't be a child of the element on which `cancel` is applied");const r=e.composedPath()[0];if(!z.some((t=>t.contains(r)||t.shadowRoot?.contains(r)))||c(F,[r]))return;G=1===z.length?t:z.find((t=>t.contains(r))),R=!0,O=t.getBoundingClientRect(),y&&(I=K.userSelect,K.userSelect="none"),Z("neodrag:start",$);const{clientX:i,clientY:s}=e,l=et();n&&(P=i-q/l),o&&(X=s-U/l),W&&(Y=i-O.left,k=s-O.top)}function rt(){R&&(v.dragEnd&&(W=d(f,t)),Q.remove(N),Q.add(M),y&&(K.userSelect=I),Z("neodrag:end",L),n&&(P=T),o&&(X=j),R=!1)}function ot(e){if(!R)return;v.drag&&(W=d(f,t)),Q.add(N),e.preventDefault(),O=t.getBoundingClientRect();let r=e.clientX,a=e.clientY;const c=et();if(W){const t={left:W.left+Y,top:W.top+k,right:W.right+Y-O.width,bottom:W.bottom+k-O.height};r=i(r,t.left,t.right),a=i(a,t.top,t.bottom)}if(Array.isArray(D)){let[t,e]=D;if(isNaN(+t)||t<0)throw new Error("1st argument of `grid` must be a valid positive number");if(isNaN(+e)||e<0)throw new Error("2nd argument of `grid` must be a valid positive number");let n=r-P,o=a-X;[n,o]=s([t/c,e/c],n,o),r=P+n,a=X+o}if(n&&(T=Math.round((r-P)*c)),o&&(j=Math.round((a-X)*c)),q=T,U=j,tt){tt(r*r+a*a-(P*P+X*X))}Z("neodrag",H),V()}return{destroy:()=>{const t=removeEventListener;t("pointerdown",nt,!1),t("pointerup",rt,!1),t("pointermove",ot,!1)},update:t=>{g=t.axis||"both",b=t.disabled??!1,w=t.ignoreMultitouch??!1,x=t.handle,f=t.bounds,v=t.recomputeBounds??r,S=t.cancel,y=t.applyUserSelectHack??!0,D=t.grid,p=t.gpuAcceleration??!0,h=t.legacyTranslate??!0,m=t.transform;const e=Q.contains(M);Q.remove(C,M),C=t.defaultClass??"neodrag",N=t.defaultClassDragging??"neodrag-dragging",M=t.defaultClassDragged??"neodrag-dragged",Q.add(C),e&&Q.add(M),J&&(q=T=t.position?.x??T,U=j=t.position?.y??j,V())}}},i=(t,e,n)=>Math.min(Math.max(t,e),n),a=t=>"string"==typeof t,s=([t,e],n,r)=>{const o=(t,e)=>0===e?0:Math.ceil(t/e)*e;return[o(n,t),o(r,e)]};var c=(t,e)=>t.some((t=>e.some((e=>t.contains(e)))));function d(t,e){if(void 0===t)return;if(u(t))return t.getBoundingClientRect();if("object"==typeof t){const{top:e=0,left:n=0,right:r=0,bottom:o=0}=t;return{top:e,right:window.innerWidth-r,bottom:window.innerHeight-o,left:n}}if("parent"===t)return e.parentNode.getBoundingClientRect();const n=document.querySelector(t);if(null===n)throw new Error("The selector provided for bound doesn't exists in the document.");return n.getBoundingClientRect()}var l=(t,e,n)=>t.style.setProperty(e,n),u=t=>t instanceof HTMLElement;function f(t){return null==t||"string"==typeof t||t instanceof HTMLElement?t:"current"in t?t.current:Array.isArray(t)?t.map((t=>t instanceof HTMLElement?t:t.current)):void 0}function g(r,i={}){const a=t(),[s,c]=e(!1),[d,l]=e();let{onDragStart:u,onDrag:g,onDragEnd:p,handle:h,cancel:m}=i,y=f(h),b=f(m);function w(t,e){l(t),e?.(t)}function v(t){c(!0),w(t,u)}function D(t){w(t,g)}function E(t){c(!1),w(t,p)}return n((()=>{if("undefined"==typeof window)return;const t=r.current;if(!t)return;({onDragStart:u,onDrag:g,onDragEnd:p}=i);const{update:e,destroy:n}=o(t,{...i,handle:y,cancel:b,onDragStart:v,onDrag:D,onDragEnd:E});return a.current=e,n}),[]),n((()=>{a.current?.({...i,handle:f(h),cancel:f(m),onDragStart:v,onDrag:D,onDragEnd:E})}),[i]),{isDragging:s,dragState:d}}export{g as useDraggable};