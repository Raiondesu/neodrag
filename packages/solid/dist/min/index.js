import{onCleanup as t,createEffect as e}from"solid-js";var n={dragStart:!0},o=(t,e={})=>{let o,u,{bounds:f,axis:g="both",gpuAcceleration:p=!0,legacyTranslate:h=!0,transform:m,applyUserSelectHack:y=!0,disabled:b=!1,ignoreMultitouch:w=!1,recomputeBounds:v=n,grid:x,position:E,cancel:A,handle:S,touchAction:C="none",defaultClass:N="neodrag",defaultClassDragging:D="neodrag-dragging",defaultClassDragged:M="neodrag-dragged",defaultPosition:B={x:0,y:0},onDragStart:$,onDrag:R,onDragEnd:j}=e,H=!1,L=0,P=0,T=0,X=0,Y=0,k=0,{x:q,y:U}=E?{x:E?.x??0,y:E?.y??0}:B;V(q,U);let W,O,z,F,G,I="",J=!!E;v={...n,...v};const K=document.body.style,Q=t.classList;function V(e=L,n=P){if(!m){if(h){let o=`${+e}px, ${+n}px`;return l(t,"transform",p?`translate3d(${o}, 0)`:`translate(${o})`)}return l(t,"translate",`${+e}px ${+n}px ${p?"1px":""}`)}const o=m({offsetX:e,offsetY:n,rootNode:t});i(o)&&l(t,"transform",o)}const Z=(e,n)=>{const o={offsetX:L,offsetY:P,rootNode:t,currentNode:G};t.dispatchEvent(new CustomEvent(e,{detail:o})),n?.(o)};const _=addEventListener;let tt;if(_("pointerdown",nt,!1),_("pointerup",ot,!1),_("pointermove",rt,!1),"function"==typeof C)C(t,(e=>l(t,"touch-action",e)));else if("string"==typeof C)l(t,"touch-action",C);else{const e=Object.keys(C).map((t=>Number(t))).sort();tt=n=>{const o=e.find((t=>n>=t));if("object"!=typeof C||"number"!=typeof o||"object"==typeof C&&!(o in C))return;const r=C[o];"string"==typeof r&&l(t,"touch-action",r)}}const et=()=>{let e=t.offsetWidth/O.width;return isNaN(e)&&(e=1),e};function nt(e){if(b)return;if(2===e.button)return;if(w&&!e.isPrimary)return;if(v.dragStart&&(W=d(f,t)),i(S)&&i(A)&&S===A)throw new Error("`handle` selector can't be same as `cancel` selector");if(Q.add(N),z=function(t,e){if(!t)return[e];if(c(t))return[t];if(Array.isArray(t))return t;const n=e.querySelectorAll(t);if(null===n)throw new Error("Selector passed for `handle` option should be child of the element on which the action is applied");return Array.from(n.values())}(S,t),F=function(t,e){if(!t)return[];if(c(t))return[t];if(Array.isArray(t))return t;const n=e.querySelectorAll(t);if(null===n)throw new Error("Selector passed for `cancel` option should be child of the element on which the action is applied");return Array.from(n.values())}(A,t),o=/(both|x)/.test(g),u=/(both|y)/.test(g),s(F,z))throw new Error("Element being dragged can't be a child of the element on which `cancel` is applied");const n=e.composedPath()[0];if(!z.some((t=>t.contains(n)||t.shadowRoot?.contains(n)))||s(F,[n]))return;G=1===z.length?t:z.find((t=>t.contains(n))),H=!0,O=t.getBoundingClientRect(),y&&(I=K.userSelect,K.userSelect="none"),Z("neodrag:start",$);const{clientX:r,clientY:a}=e,l=et();o&&(T=r-q/l),u&&(X=a-U/l),W&&(Y=r-O.left,k=a-O.top)}function ot(){H&&(v.dragEnd&&(W=d(f,t)),Q.remove(D),Q.add(M),y&&(K.userSelect=I),Z("neodrag:end",j),o&&(T=L),u&&(X=P),H=!1)}function rt(e){if(!H)return;v.drag&&(W=d(f,t)),Q.add(D),e.preventDefault(),O=t.getBoundingClientRect();let n=e.clientX,i=e.clientY;const s=et();if(W){const t={left:W.left+Y,top:W.top+k,right:W.right+Y-O.width,bottom:W.bottom+k-O.height};n=r(n,t.left,t.right),i=r(i,t.top,t.bottom)}if(Array.isArray(x)){let[t,e]=x;if(isNaN(+t)||t<0)throw new Error("1st argument of `grid` must be a valid positive number");if(isNaN(+e)||e<0)throw new Error("2nd argument of `grid` must be a valid positive number");let o=n-T,r=i-X;[o,r]=a([t/s,e/s],o,r),n=T+o,i=X+r}if(o&&(L=Math.round((n-T)*s)),u&&(P=Math.round((i-X)*s)),q=L,U=P,tt){tt(n*n+i*i-(T*T+X*X))}Z("neodrag",R),V()}return{destroy:()=>{const t=removeEventListener;t("pointerdown",nt,!1),t("pointerup",ot,!1),t("pointermove",rt,!1)},update:t=>{g=t.axis||"both",b=t.disabled??!1,w=t.ignoreMultitouch??!1,S=t.handle,f=t.bounds,v=t.recomputeBounds??n,A=t.cancel,y=t.applyUserSelectHack??!0,x=t.grid,p=t.gpuAcceleration??!0,h=t.legacyTranslate??!0,m=t.transform;const e=Q.contains(M);Q.remove(N,M),N=t.defaultClass??"neodrag",D=t.defaultClassDragging??"neodrag-dragging",M=t.defaultClassDragged??"neodrag-dragged",Q.add(N),e&&Q.add(M),J&&(q=L=t.position?.x??L,U=P=t.position?.y??P,V())}}},r=(t,e,n)=>Math.min(Math.max(t,e),n),i=t=>"string"==typeof t,a=([t,e],n,o)=>{const r=(t,e)=>0===e?0:Math.ceil(t/e)*e;return[r(n,t),r(o,e)]};var s=(t,e)=>t.some((t=>e.some((e=>t.contains(e)))));function d(t,e){if(void 0===t)return;if(c(t))return t.getBoundingClientRect();if("object"==typeof t){const{top:e=0,left:n=0,right:o=0,bottom:r=0}=t;return{top:e,right:window.innerWidth-o,bottom:window.innerHeight-r,left:n}}if("parent"===t)return e.parentNode.getBoundingClientRect();const n=document.querySelector(t);if(null===n)throw new Error("The selector provided for bound doesn't exists in the document.");return n.getBoundingClientRect()}var l=(t,e,n)=>t.style.setProperty(e,n),c=t=>t instanceof HTMLElement,u=()=>({draggable:(n,r)=>{const{update:i,destroy:a}=o(n,r());t(a),e((()=>i(r())))}});export{u as createDraggable};